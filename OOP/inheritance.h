#pragma once

#include <iostream>
#include <string>
#include "common.h"

/*
 * Наследование
 *
 *  - это процесс, при котором на базе УЖЕ существующего класса создается новый класс со всеми полями и методами прежнего.
 *
 *      Класс ОТ которого идет наследование называет РОДИТЕЛЬСКИМ
 *      Класс КОТОРЫЙ наследует параметры родительского НАСЛЕДНИКОМ
 *
 *  ВАЖНО - Наследники знают о Родителях все что доступно, Родители НИЧЕГО НЕ ЗНАЮ о наследниках
 *
 *  Синтаксис:
 *
 *      При создании класса наследника:
 *          class <Имя класса наследника> : <модификатор доступа наследования> <Имя класса родителя>
 *          class Inherit : public Parent
 *
 *      ВАЖНО - Для того что бы ЗАПРЕТИТЬ наследования от класса необходимо добавить модификатор
 *          final к его названию
 *          class Parent final  //-> запрещает наследование от Parent
 *          {}
 *
 *      <модификатор доступа наследования> - это модификатор, который говорит под каким доступом будут
 *              у НАСЛЕДНИКА поля и методы РОДИТЕЛЯ
 *      ВАЖНО - В C++ применяется по-умолчанию модификатор доступа наследования private
 *
 *      Модификаторы доступа:
 *
 *      public    - полный доступ из любой части кода
 *      protected - запрещает доступ извне, но разрешает внутри методов класса и наследникам класса
 *      private   - запрет для доступа извне, разрешен только методам класса
 *          |
 *          V
 *      public - Доступно везде
 *      protected - Извне недоступно, но разрешено внутри класса и классам наследникам
 *      private - Извне и классам наследникам недоступно, но разрешено внутри класса
 *
 *      Сборка каждого объекта наследника происходит по принципу Матрешки:
 *          Сначала собирается самый первый родитель, а дальше каждый наследник наслаивает
 *              свои поля и методы
 *
 */

/*
 * Полиморфизм
 *
 *      Это возможность использовать объекты наследников КАК объекты родителей
 *
 *
 * Виртуальные функции и Виртуальный Деструктор -> Динамический Полиморфизм
 *
 *  Перегрузка методов родителя в наследниках позволяет создать новую реализацию для уже имеющегося метода.
 *      ВАЖНО - При выборе какую реализацию выполнить программа смотрит, есть ли реализация в наследнике и, если ее нет - идет искать ее в родителе.
 *
 *
 *  Виртуальные функции (Виртуальные методы) - это функци класса, которые перед выполнением обязаны проверить "А кто вызывает этот метод?" и если это указатель на класс, внутри которого находится объект класса наследника - он вызовет реализацию НАСЛЕДНИКА, иначе вызовется реализация РОДИТЕЛЯ
 *
 *      Синтаксис:
 *          virtual <возвращаемое значение> <имя метода> (<параметры метода>);
 *
 *  override - служит для проверки сигнатуры функции на соответствие родительской - то есть, если вдруг вы укажете какие либо лишние параметры или поменяете порядок параметров или по любой другой причине он будет соответствовать тому как объявлена функция в родителе - Получите ошибку на сборке.
 *
 *  Виртуальный деструктор служит ТОЛЬКО для того, чтобы перенаправлять удаление указателя родителя на деструктор наследника, если внутри указателя лежит объект наследника
 *
 *      ВАЖНО - Виртуальным может быть ТОЛЬКО Деструктор.
 *      АРХИВАЖНО - У ЛЮБОГО КЛАССА НЕ FINAL ОБЯЗАН быть virtual Деструктор
 *
 *
 */

class Parent
{
public:

    Parent();
    virtual ~Parent();

    Parent(const double& value);

    double getValue(                );
    bool   setValue(const int& value);

    friend std::istream& operator>> (std::istream& stream,       Parent& object);
    friend std::ostream& operator<< (std::ostream& stream, const Parent& object);

    virtual std::string getName();

    static void sayHello();

protected:
    DELETE_COPY_CONSTRUCTOR(Parent)

    double _value;
};

class Inherit : public Parent
{
public:

    Inherit();
    virtual ~Inherit();

    Inherit(const double& real, const double& imagen);

    double getReal(                );
    bool   setReal(const int& value);

    double getImgn(                );
    bool   setImgn(const int& value);

    friend std::istream& operator>> (std::istream& stream,       Inherit& object);
    friend std::ostream& operator<< (std::ostream& stream, const Inherit& object);

    virtual std::string getName() override;

private:
    DELETE_COPY_CONSTRUCTOR(Inherit)

    double _imgn;
};



